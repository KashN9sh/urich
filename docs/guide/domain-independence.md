# Независимость от Urich: что должно быть без фреймворка

В теории **без Urich** стоит держать всё, что относится к **домену** и к **портам** (интерфейсам, которые домен или приложение задаёт, а инфраструктура реализует). Ниже — что уже без Urich и что ещё может тянуть фреймворк.

## Уже без Urich (или можно сделать так)

- **Агрегаты и события** — домен может быть чистыми типами: свои классы, датаклассы, без наследования от `DomainEvent`. Публикация событий выполняется в хендлере; фреймворк не навязывает агрегату никакого контракта. EventBus в Urich принимает `event: object` и `event_type: type`. См. [Домен без Urich](domain-without-framework.md).
- **Сущности и value-объекты** — можно не наследовать `Entity` и `ValueObject` из Urich, а описать свои типы в домене.

## Что ещё часто тянет Urich и в теории может быть своим

### 1. Интерфейс репозитория

Сейчас часто: `class IOrderRepository(Repository[Order])` с `from urich.domain import Repository` — зависимость от Urich.

**В теории:** интерфейс репозитория — ваш контракт: свой `Protocol` или ABC с методами `get` / `add` / `save` в вашем коде, без импорта `Repository` из Urich. Реализация в инфраструктуре просто реализует этот контракт; фреймворк подставляет её в DI. Домен и приложение тогда не знают про Urich.

### 2. Базовые классы домена в других модулях

В части примеров до сих пор: `OrderCreated(DomainEvent)` — домен может тянуть Urich.

**В теории:** те же принципы, что и в «домене без Urich»: свои классы и датаклассы, без наследования от `Entity`, `DomainEvent`, `ValueObject`. Каждый bounded context может выбирать: либо свои типы, либо базовые классы Urich (Entity, ValueObject, DomainEvent) для быстрого старта.

### 3. Command / Query

Команды и запросы наследуют `Command` и `Query` из `urich.ddd` — слой приложения знает про Urich.

**В теории:** можно было бы иметь свои маркеры и маппить их в Urich при регистрации. На практике Command/Query обычно считают частью контракта «приложение ↔ фреймворк», и зависимость приложения от Urich здесь часто принимают сознательно.

### 4. EventBus в хендлерах

Тип `EventBus` из `urich.domain` в конструкторе хендлера — зависимость приложения от типа из Urich.

**В теории:** приложение может зависеть только от своего протокола «шина событий» (объявленного у вас в коде). Urich подставляет реализацию, совместимую с этим протоколом. Тогда в приложении не будет импорта `EventBus` из Urich.

---

## Итог

**Строго без Urich:** весь домен (агрегаты, события, сущности, value-объекты, **интерфейсы репозиториев**). Опционально — тип «шина событий» в приложении.

**Сейчас часто «с Urich» остаются:** интерфейс репозитория (`Repository[T]`), базовые классы домена в части модулей, Command/Query и тип EventBus в приложении. По мере необходимости их можно заменять своими контрактами, оставляя Urich только в слое сборки (модули, роуты, DI).
